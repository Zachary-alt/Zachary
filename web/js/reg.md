## 正则表达式

> 正则表达式是由一个字符串序列形成的搜索模式
>
> 语法： /正则表达式主体/修饰符（可选）

- 修饰符

  | 修饰符 | 描述                                   |
  | ------ | -------------------------------------- |
  | i      | 执行对大小写不敏感的匹配               |
  | g      | 执行全局匹配                           |
  | m      | 执行多行匹配                           |
  | s      | 特殊字符圆点 **.** 中包含换行符 **\n** |

  m修饰符的作用是修改^和$在正则表达式中的作用，让它们分别表示行首和行尾，默认情况下，一个字符串不论是否换行只有一个开始^和一个结尾$，如果采用多行匹配，那么每一行都有一个^和$

  ```js
  let str = 'This is an\n antzone good'
  let reg = /an$/
  console.log(str.match(reg))
  //匹配不到，因为虽然加了/n，但是没有多行匹配，所以不是字符串的结尾
  let str = 'This is an\n antzone good'
  let reg = /an$/m
  console.log(str.match(reg))
  //这样就可以匹配到了
  ```

### 正则表达式常用符号

| **符号** | **描述**                                               |
| -------- | ------------------------------------------------------ |
| **\s**   | **匹配任何的空白字符**                                 |
| **\S**   | **任何非空白字符**                                     |
| **\d**   | **匹配一个数字字符，等价于[0-9]**                      |
| **\D**   | **除了数字之外的任何字符，等价于[^0-9**]               |
| **\w**   | **匹配一个数字、下划线或字母字符，等价于[A-Za-z0-9_]** |
| **\W**   | **任何非单字字符，等价于[^a-zA-z0-9_**]                |
| **.**    | **匹配除了换行符之外的任意字符**                       |

大写的\s、\d、\w与小写的意思正好正反

### 限定符

| **符号**  | **描述**                                                    |
| --------- | ----------------------------------------------------------- |
| **{n}**   | **匹配前一项n次**                                           |
| **{n,}**  | **匹配前一项n次，或者多次**                                 |
| **{n,m}** | **匹配前一项至少n次，但是不能超过m次**                      |
| *         | **匹配前一项0次或多次，等价于{0,}**                         |
| **+**     | **匹配前一项1次或多次，等价于{1,}**                         |
| **?**     | **匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}** |

### 特殊字符

| **符号**  | **描述**                                                     |
| --------- | ------------------------------------------------------------ |
| **/…/**   | **代表一个模式的开始和结束**                                 |
| **^**     | **匹配字符串的开始，即表示行的开始**                         |
| **$**     | **匹配字符串的结束，即表示行的结束**                         |
| **[  ]**  | **表示可匹配的列表**                                         |
| **()**    | **() 表示捕获分组，() 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(n 是一个数字，表示第 n 个捕获组的内容)。** |
| **\|**    | **表示或者**                                                 |
| **[ ^ ]** | **在[  ]中的尖括号表示非**                                   |

## 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\b** 描述单词的前或后边界，**\B** 表示非单词边界。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

**注意**：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符。不要将 **^** 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 **$** 字符。

## 选择

用圆括号 **()** 将所有选择项括起来，相邻的选择项之间用 **|** 分隔。

**()** 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(**n** 是一个数字，表示第 n 个捕获组的内容)。

![img](https://www.runoob.com/wp-content/uploads/2014/03/366574CC-3706-4B4C-8782-1BFF4CF57582.jpg)

![img](https://www.runoob.com/wp-content/uploads/2014/03/82A7298A-2A94-49E3-AA27-A7778EE89711.jpg)

但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 **?:** 放在第一个选项前来消除这种副作用。

其中 **?:** 是非捕获元之一，还有两个非捕获元是 **?=** 和 **?!**，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

### 以下列出 ?=、?<=、?!、?<! 的使用区别

**exp1(?=exp2)**：查找 exp2 前面的 exp1。

![img](https://www.runoob.com/wp-content/uploads/2014/03/reg-111.jpg)

**(?<=exp2)exp1**：查找 exp2 后面的 exp1。

![img](https://www.runoob.com/wp-content/uploads/2014/03/reg-222.jpg)

**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。

![img](https://www.runoob.com/wp-content/uploads/2014/03/reg-333.jpg)

**(?<!exp2)exp1**：查找前面不是 exp2 的 exp1。

![img](https://www.runoob.com/wp-content/uploads/2014/03/reg-444.jpg)

> *更多内容可以参考：*[正则表达式的先行断言(lookahead)和后行断言(lookbehind)](https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html)

### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 **\n** 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。

反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：

```
Is is the cost of of gasoline going up up?
```

上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：

#### 实例

查找重复的单词：

```js
var str = "Is is the cost of of gasoline going up up"; 
var patt1 = /\b([a-z]+) \1\b/ig; 
document.write(str.match(patt1));
```

[尝试一下 »](https://www.runoob.com/try/try.php?filename=tryjsref_regexp3)

捕获的表达式，正如 **[a-z]+** 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。**\1** 指定第一个子匹配项。

单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。

正则表达式后面的全局标记 **g** 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。

表达式的结尾处的不区分大小写 **i** 标记指定不区分大小写。

多行标记指定换行符的两边可能出现潜在的匹配。

## [JavaScript replace() 方法](https://www.w3school.com.cn/jsref/jsref_replace.asp)

replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

### 语法

```js
stringObject.replace(regexp/substr,replacement)
```

字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 *replacement* 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

*replacement* 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。

| 字符             | 替换文本                                            |
| :--------------- | :-------------------------------------------------- |
| $1、$2、...、$99 | 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 |
| $&               | 与 regexp 相匹配的子串。                            |
| $`               | 位于匹配子串左侧的文本。                            |
| $'               | 位于匹配子串右侧的文本。                            |
| $$               | 直接量符号。                                        |

**注意：**ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。

在本例中，我们将把字符串中所有单词的首字母都转换为大写：

```js
name = 'aaa bbb ccc';
uw=name.replace(/\b\w+\b/g, function(word){
  return word.substring(0,1).toUpperCase()+word.substring(1);}
  );
```

将数字转换成千分位展示:

```js
function format (num) {  
    var reg=/\d{1,3}(?=(\d{3})+$)/g;   
    return (num + '').replace(reg, '$&,');  
}
// 正则表达式 \d{1,3}(?=(\d{3})+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾
// ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始
// $& 表示与正则表达式相匹配的内容
```

