(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{441:function(t,e,a){"use strict";a.r(e);var r=a(42),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("本质上，"),a("em",[t._v("webpack")]),t._v(" 是一个现代 JavaScript 应用程序的"),a("em",[t._v("静态模块打包器(module bundler)")]),t._v("。当 webpack 处理应用程序时，它会递归地构建一个"),a("em",[t._v("依赖关系图(dependency graph)")]),t._v("，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 "),a("em",[t._v("bundle")]),t._v("。")]),t._v(" "),a("p",[t._v("从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是"),a("a",{attrs:{href:"https://www.webpackjs.com/configuration",target:"_blank",rel:"noopener noreferrer"}},[t._v("高度可配置的"),a("OutboundLink")],1),t._v("。在开始前你需要先理解四个"),a("strong",[t._v("核心概念")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("入口(entry)")]),t._v(" "),a("li",[t._v("输出(output)")]),t._v(" "),a("li",[t._v("loader")]),t._v(" "),a("li",[t._v("插件(plugins)")])]),t._v(" "),a("h2",{attrs:{id:"入口-entry"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#入口-entry"}},[t._v("#")]),t._v(" 入口(entry)")]),t._v(" "),a("p",[t._v("**入口起点(entry point)**指示 webpack 应该使用哪个模块，来作为构建其内部"),a("em",[t._v("依赖图")]),t._v("的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。")]),t._v(" "),a("p",[t._v("每个依赖项随即被处理，最后输出到称之为 "),a("em",[t._v("bundles")]),t._v(" 的文件中")]),t._v(" "),a("h2",{attrs:{id:"出口-output"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#出口-output"}},[t._v("#")]),t._v(" 出口(output)")]),t._v(" "),a("p",[a("strong",[t._v("output")]),t._v(" 属性告诉 webpack 在哪里输出它所创建的 "),a("em",[t._v("bundles")]),t._v("，以及如何命名这些文件，默认值为 "),a("code",[t._v("./dist")]),t._v("。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 "),a("code",[t._v("output")]),t._v(" 字段，来配置这些处理过程")]),t._v(" "),a("blockquote",[a("p",[t._v("配置 "),a("code",[t._v("output")]),t._v(" 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个"),a("code",[t._v("入口")]),t._v("起点，但只指定一个"),a("code",[t._v("输出")]),t._v("配置。")])]),t._v(" "),a("h3",{attrs:{id:"多个入口起点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个入口起点"}},[t._v("#")]),t._v(" 多个入口起点")]),t._v(" "),a("p",[t._v('如果配置创建了多个单独的 "chunk"（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用'),a("a",{attrs:{href:"https://www.webpackjs.com/configuration/output#output-filename",target:"_blank",rel:"noopener noreferrer"}},[t._v("占位符(substitutions)"),a("OutboundLink")],1),t._v("来确保每个文件具有唯一的名称。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  entry"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    app"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./src/app.js'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    search"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./src/search.js'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  output"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    filename"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'[name].js'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" __dirname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/dist'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 写入到硬盘：./dist/app.js, ./dist/search.js")]),t._v("\n")])])]),a("h3",{attrs:{id:"高级进阶"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级进阶"}},[t._v("#")]),t._v(" 高级进阶")]),t._v(" "),a("p",[t._v("以下是使用 CDN 和资源 hash 的复杂示例：")]),t._v(" "),a("p",[a("strong",[t._v("config.js")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("output"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/home/proj/cdn/assets/[hash]"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  publicPath"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"http://cdn.example.com/assets/[hash]/"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在编译时不知道最终输出文件的 "),a("code",[t._v("publicPath")]),t._v(" 的情况下，"),a("code",[t._v("publicPath")]),t._v(" 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 "),a("code",[t._v("publicPath")]),t._v("，你可以先忽略它，并且在入口起点设置 "),a("code",[t._v("__webpack_public_path__")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("__webpack_public_path__ "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" myRuntimePublicPath\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 剩余的应用程序入口")]),t._v("\n")])])]),a("h2",{attrs:{id:"loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/concepts/loaders/",target:"_blank",rel:"noopener noreferrer"}},[t._v("loader"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("em",[t._v("loader")]),t._v(" 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效"),a("a",{attrs:{href:"https://www.webpackjs.com/concepts/modules",target:"_blank",rel:"noopener noreferrer"}},[t._v("模块"),a("OutboundLink")],1),t._v("，然后你就可以利用 webpack 的打包能力，对它们进行处理。")]),t._v(" "),a("p",[t._v("本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。")]),t._v(" "),a("p",[t._v("loader 用于对模块的源代码进行转换。loader 可以使你在 "),a("code",[t._v("import")]),t._v(' 或"加载"模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 '),a("code",[t._v("import")]),t._v(" CSS文件！")]),t._v(" "),a("blockquote",[a("p",[t._v("注意，loader 能够 "),a("code",[t._v("import")]),t._v(" 导入任何类型的模块（例如 "),a("code",[t._v(".css")]),t._v(" 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。")])]),t._v(" "),a("p",[t._v("在更高层面，在 webpack 的配置中 "),a("strong",[t._v("loader")]),t._v(" 有两个目标：")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("test")]),t._v(" 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。")]),t._v(" "),a("li",[a("code",[t._v("use")]),t._v(" 属性，表示进行转换时，应该使用哪个 loader。")])]),t._v(" "),a("h3",{attrs:{id:"loader-特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader-特性"}},[t._v("#")]),t._v(" loader 特性")]),t._v(" "),a("ul",[a("li",[t._v("loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。")]),t._v(" "),a("li",[t._v("loader 可以是同步的，也可以是异步的。")]),t._v(" "),a("li",[t._v("loader 运行在 Node.js 中，并且能够执行任何可能的操作。")]),t._v(" "),a("li",[t._v("loader 接收查询参数。用于对 loader 传递配置。")]),t._v(" "),a("li",[t._v("loader 也能够使用 "),a("code",[t._v("options")]),t._v(" 对象进行配置。")]),t._v(" "),a("li",[t._v("除了使用 "),a("code",[t._v("package.json")]),t._v(" 常见的 "),a("code",[t._v("main")]),t._v(" 属性，还可以将普通的 npm 模块导出为 loader，做法是在 "),a("code",[t._v("package.json")]),t._v(" 里定义一个 "),a("code",[t._v("loader")]),t._v(" 字段。")]),t._v(" "),a("li",[t._v("插件(plugin)可以为 loader 带来更多特性。")]),t._v(" "),a("li",[t._v("loader 能够产生额外的任意文件。")])]),t._v(" "),a("h3",{attrs:{id:"编写一个-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写一个-loader"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/contribute/writing-a-loader/",target:"_blank",rel:"noopener noreferrer"}},[t._v("编写一个 loader"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"插件-plugins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件-plugins"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/concepts/plugins/",target:"_blank",rel:"noopener noreferrer"}},[t._v("插件(plugins)"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。"),a("a",{attrs:{href:"https://www.webpackjs.com/api/plugins",target:"_blank",rel:"noopener noreferrer"}},[t._v("插件接口"),a("OutboundLink")],1),t._v("功能极其强大，可以用来处理各种各样的任务。")]),t._v(" "),a("p",[t._v("想要使用一个插件，你只需要 "),a("code",[t._v("require()")]),t._v(" 它，然后把它添加到 "),a("code",[t._v("plugins")]),t._v(" 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 "),a("code",[t._v("new")]),t._v(" 操作符来创建它的一个实例。")]),t._v(" "),a("p",[t._v("插件是 webpack 的"),a("a",{attrs:{href:"https://github.com/webpack/tapable",target:"_blank",rel:"noopener noreferrer"}},[t._v("支柱"),a("OutboundLink")],1),t._v("功能。webpack 自身也是构建于，你在 webpack 配置中用到的"),a("strong",[t._v("相同的插件系统")]),t._v("之上！")]),t._v(" "),a("p",[t._v("插件目的在于解决 "),a("a",{attrs:{href:"https://www.webpackjs.com/concepts/loaders",target:"_blank",rel:"noopener noreferrer"}},[t._v("loader"),a("OutboundLink")],1),t._v(" 无法实现的"),a("strong",[t._v("其他事")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#剖析"}},[t._v("#")]),t._v(" 剖析")]),t._v(" "),a("p",[t._v("webpack "),a("strong",[t._v("插件")]),t._v("是一个具有 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("apply")]),a("OutboundLink")],1),t._v(" 属性的 JavaScript 对象。"),a("code",[t._v("apply")]),t._v(" 属性会被 webpack compiler 调用，并且 compiler 对象可在"),a("strong",[t._v("整个")]),t._v("编译生命周期访问。")]),t._v(" "),a("p",[a("strong",[t._v("ConsoleLogOnBuildWebpackPlugin.js")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" pluginName "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ConsoleLogOnBuildWebpackPlugin'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ConsoleLogOnBuildWebpackPlugin")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("compiler")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        compiler"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hooks"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("run"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pluginName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("compilation")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"webpack 构建过程开始！"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。")]),t._v(" "),a("h3",{attrs:{id:"编写一个插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写一个插件"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/contribute/writing-a-plugin/",target:"_blank",rel:"noopener noreferrer"}},[t._v("编写一个插件"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"模式-mode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模式-mode"}},[t._v("#")]),t._v(" 模式(mode)")]),t._v(" "),a("p",[t._v("提供 "),a("code",[t._v("mode")]),t._v(" 配置选项，告知 webpack 使用相应模式的内置优化。")]),t._v(" "),a("h3",{attrs:{id:"用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),a("p",[t._v("只在配置中提供 "),a("code",[t._v("mode")]),t._v(" 选项：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  mode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'production'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("或者从 "),a("a",{attrs:{href:"https://www.webpackjs.com/api/cli/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CLI"),a("OutboundLink")],1),t._v(" 参数中传递：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("webpack --mode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("production\n")])])]),a("p",[t._v("支持以下字符串值：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("选项")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("development")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("会将 "),a("code",[t._v("process.env.NODE_ENV")]),t._v(" 的值设为 development。启用 "),a("code",[t._v("NamedChunksPlugin")]),t._v(" 和 "),a("code",[t._v("NamedModulesPlugin")])])]),t._v(" "),a("tr",[a("td",[t._v("production")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("会将 "),a("code",[t._v("DefinePlugin")]),t._v(" 中 "),a("code",[t._v("process.env.NODE_ENV")]),t._v(" 的值设置为 production。启用 "),a("code",[t._v("FlagDependencyUsagePlugin")]),t._v(", "),a("code",[t._v("FlagIncludedChunksPlugin")]),t._v(", "),a("code",[t._v("ModuleConcatenationPlugin")]),t._v(", "),a("code",[t._v("NoEmitOnErrorsPlugin")]),t._v(", "),a("code",[t._v("OccurrenceOrderPlugin")]),t._v(", "),a("code",[t._v("SideEffectsFlagPlugin")]),t._v(" 和 "),a("code",[t._v("TerserPlugin")]),t._v("。")])]),t._v(" "),a("tr",[a("td",[t._v("none")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("退出任何默认优化选项")])])])]),t._v(" "),a("blockquote",[a("p",[a("em",[t._v("记住，只设置")]),t._v(" "),a("code",[t._v("NODE_ENV")]),a("em",[t._v("，则不会自动设置")]),t._v(" "),a("code",[t._v("mode")]),a("em",[t._v("。")])])]),t._v(" "),a("h2",{attrs:{id:"tree-shaking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/guides/tree-shaking/",target:"_blank",rel:"noopener noreferrer"}},[t._v("tree shaking"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("em",[t._v("tree shaking")]),t._v(" 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的"),a("a",{attrs:{href:"http://exploringjs.com/es6/ch_modules.html#static-module-structure",target:"_blank",rel:"noopener noreferrer"}},[t._v("静态结构特性"),a("OutboundLink")],1),t._v("，例如 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("import")]),a("OutboundLink")],1),t._v(" 和 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("export")]),a("OutboundLink")],1),t._v("。这个术语和概念实际上是兴起于 ES2015 模块打包工具 "),a("a",{attrs:{href:"https://github.com/rollup/rollup",target:"_blank",rel:"noopener noreferrer"}},[t._v("rollup"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("新的 webpack 4 正式版本，扩展了这个检测能力，通过 "),a("code",[t._v("package.json")]),t._v(" 的 "),a("code",[t._v('"sideEffects"')]),t._v(' 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。')]),t._v(" "),a("h2",{attrs:{id:"代码分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码分离"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/guides/code-splitting/",target:"_blank",rel:"noopener noreferrer"}},[t._v("代码分离"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。")]),t._v(" "),a("p",[t._v("有三种常用的代码分离方法：")]),t._v(" "),a("ul",[a("li",[t._v("入口起点：使用 "),a("a",{attrs:{href:"https://www.webpackjs.com/configuration/entry-context",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("entry")]),a("OutboundLink")],1),t._v(" 配置手动地分离代码。")]),t._v(" "),a("li",[t._v("防止重复：使用 "),a("a",{attrs:{href:"https://www.webpackjs.com/plugins/commons-chunk-plugin",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("CommonsChunkPlugin")]),a("OutboundLink")],1),t._v(" 去重和分离 chunk。")]),t._v(" "),a("li",[t._v("动态导入：通过模块的内联函数调用来分离代码。")])]),t._v(" "),a("h2",{attrs:{id:"懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#懒加载"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/guides/lazy-loading/",target:"_blank",rel:"noopener noreferrer"}},[t._v("懒加载"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。")]),t._v(" "),a("h2",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/guides/caching/",target:"_blank",rel:"noopener noreferrer"}},[t._v("缓存"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("此指南的重点在于通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。")]),t._v(" "),a("h2",{attrs:{id:"shimming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shimming"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/guides/shimming/",target:"_blank",rel:"noopener noreferrer"}},[t._v("shimming"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("code",[t._v("webpack")]),t._v(" 编译器(compiler)能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些第三方的库(library)可能会引用一些全局依赖（例如 "),a("code",[t._v("jQuery")]),t._v(" 中的 "),a("code",[t._v("$")]),t._v("）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 "),a("em",[t._v("shimming")]),t._v(" 发挥作用的地方。")]),t._v(" "),a("p",[a("em",[t._v("shimming")]),t._v(" 另外一个使用场景就是，当你希望 "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Polyfill",target:"_blank",rel:"noopener noreferrer"}},[t._v("polyfill"),a("OutboundLink")],1),t._v(" 浏览器功能以支持更多用户时。在这种情况下，你可能只想要将这些 polyfills 提供给到需要修补(patch)的浏览器（也就是实现按需加载）。")]),t._v(" "),a("h2",{attrs:{id:"渐进式网络应用程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渐进式网络应用程序"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.webpackjs.com/guides/progressive-web-application/",target:"_blank",rel:"noopener noreferrer"}},[t._v("渐进式网络应用程序"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在**离线(offline)**时应用程序能够继续运行功能。这是通过使用名为 "),a("a",{attrs:{href:"https://developers.google.com/web/fundamentals/primers/service-workers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Service Workers"),a("OutboundLink")],1),t._v(" 的网络技术来实现的。")])])}),[],!1,null,null,null);e.default=s.exports}}]);