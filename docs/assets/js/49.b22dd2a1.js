(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{430:function(v,_,t){"use strict";t.r(_);var l=t(42),p=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"网络模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络模型"}},[v._v("#")]),v._v(" 网络模型")]),v._v(" "),t("blockquote",[t("p",[v._v("七层模型目前基本上只存在理论中，实际的网络协议是四层")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("OSI七层模型")]),v._v(" "),t("ul",[t("li",[v._v("物理层：底层数据传输，即网络设备之间物理连接的介质，以及网络设备与网络终端之间数据传递的规则，其中的数据是以比特的形式传递的")]),v._v(" "),t("li",[v._v("数据链路层：定义数据的基本格式，如何传输，如何标识，在链路层中，需要将比特流组合成字节的组合，这种我们称之为数据帧，对数据进行处理封装成数据帧并传递和错误检测的层就是数据链路层")]),v._v(" "),t("li",[v._v("网络层：定义IP编址，定义路由功能，网络层就是负责选择最佳路径，并保证数据始终沿着最佳路径传输，路由器的功能就是选合适的路径")]),v._v(" "),t("li",[v._v("传输层：端到端传输数据的基本功能，传输层就是负责将数据进行可靠或者不可靠传递，负责终端之间的传送。如：TCP、UDP")]),v._v(" "),t("li",[v._v("会话层：控制应用程序之间会话能力，会话层用来区分不同的进程，如区分两个tab页显示对应的内容")]),v._v(" "),t("li",[v._v("表示层：数据格式标识，基本压缩加密功能，对传输数据进行解密压缩等，针对不同类型数据进行格式描述")]),v._v(" "),t("li",[v._v("应用层：各种应用软件，包括web应用")])])]),v._v(" "),t("li",[t("p",[v._v("TCP/IP四层模型")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("网络接口层")]),v._v(" "),t("p",[v._v("包括用于协作IP数据在已有网络介质上传输的协议，定向的解析协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口")])]),v._v(" "),t("li",[t("p",[v._v("网间层")]),v._v(" "),t("p",[v._v("本层包含IP协议、RIP协议，负责数据的包装，寻址和路由，同时还包含网间控制报文协议用来提供网络诊断信息")])]),v._v(" "),t("li",[t("p",[v._v("传输层")]),v._v(" "),t("p",[v._v("提供两种端到端的通信服务，其中TCP协议提供可靠的数据流运输服务，UDP提供不可靠的用户数据服务")])]),v._v(" "),t("li",[t("p",[v._v("应用层")]),v._v(" "),t("p",[v._v("应用层决定了向用户提供的应用服务时的通信活动，主要有http协议、ftp协议等")])])])])]),v._v(" "),t("h2",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("三次握手")]),v._v(" "),t("p",[v._v("所谓三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送三个包")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("第一次握手")]),v._v(" "),t("p",[v._v("客户端发送带有SYN标志的数据包到服务器，并进入SYN_SEND状态，等待服务器确认")])]),v._v(" "),t("li",[t("p",[v._v("第二次握手")]),v._v(" "),t("p",[v._v("服务器收到SYN包后，回传一个带有SYN/ACK标志的数据包传递确认信息，此时服务器进入SYN_RECV状态")])]),v._v(" "),t("li",[t("p",[v._v("第三次握手")]),v._v(" "),t("p",[v._v("客户端再回传一个带有ACK标志的数据包，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手")])]),v._v(" "),t("li",[t("p",[v._v("握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据，理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去")])])])]),v._v(" "),t("li",[t("p",[v._v("四次挥手")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("第一次挥手")]),v._v(" "),t("p",[v._v("主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发送数据了（在FIN包之前发送出去的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重新发送这些数据），但是此时主动关闭方还可以接受数据")])]),v._v(" "),t("li",[t("p",[v._v("第二次挥手")]),v._v(" "),t("p",[v._v("被动关闭方收到FIN包，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号，SYN和FIN都有seq序号）")])]),v._v(" "),t("li",[t("p",[v._v("第三次挥手")]),v._v(" "),t("p",[v._v("被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了")])]),v._v(" "),t("li",[t("p",[v._v("第四次挥手")]),v._v(" "),t("p",[v._v("主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此完成四次挥手")])]),v._v(" "),t("li",[t("p",[v._v("任何一方（客户端或服务端）都可以选择主动关闭，在双方还没有完全确定关闭连接时，有可能存在没发送完的数据")])])])]),v._v(" "),t("li",[t("p",[v._v("为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？")]),v._v(" "),t("blockquote",[t("p",[v._v("这是因为服务端的LISTEN状态下的SOCKET收到SYN报文的建连请求后，可以把ACK和SYN（ACK起应答作用，SYN起同步作用）放在一个报文里来发送")]),v._v(" "),t("p",[v._v("当关闭连接时，当收到对方的FIN报文通知时，仅仅表示对方没有数据发送给你了，但未比你所有的数据都全部发送给对方了，所有不会马上关闭SOCKET，即可能还需要再发送一些数据给对方之后，再发送FIN报文给对方表示同意现在关闭连接了，所以这里的ACK报文和FIN报文多数情况下都是分开发送的")])])]),v._v(" "),t("li",[t("p",[v._v("TCP和UDP区别")]),v._v(" "),t("ul",[t("li",[v._v("TCP的可靠、稳定体现在TCP在传递数据之前，会有三次握手来建立连接，在数据传完之后，还会断开连接来节约系统资源。TCP的缺点是慢、效率低、占用系统资源高等")]),v._v(" "),t("li",[v._v("UDP是一个无状态的传输协议，所以在传递数据时非常快，但是因为UDP没有可靠的机制，数据传递时，如果网络质量不好，容易丢包")])])])]),v._v(" "),t("h2",{attrs:{id:"http"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[v._v("#")]),v._v(" HTTP")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("HTTP报文")]),v._v(" "),t("blockquote",[t("p",[v._v("起始行 + 头部 + 空行 + 实体")])])]),v._v(" "),t("li",[t("p",[v._v("HTTP1.0和HTTP1.1区别")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("长连接")]),v._v(" "),t("p",[v._v("HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接")]),v._v(" "),t("p",[v._v("HTTP是基于TCP/IP协议的，创建一个TCP连接需要经过三次握手，如果每次通讯都要重新建立连接的话，对性能有影响，因此最好能维持一个长连接，可以用长连接来发多个请求")])]),v._v(" "),t("li",[t("p",[v._v("节约带宽")]),v._v(" "),t("p",[v._v("HTTP1.1支持只发送header信息，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401，客户端如果接受到100，才可以把请求body发送到服务器")]),v._v(" "),t("p",[v._v("这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽")])]),v._v(" "),t("li",[t("p",[v._v("HOST头域")]),v._v(" "),t("p",[v._v("在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名(hostname)，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址，HTTP1.1的请求消息和响应消息都应支持HOST头域，且请求消息中如果没有HOST头域会报错(400 Bad Request)")])]),v._v(" "),t("li",[t("p",[v._v("缓存处理")]),v._v(" "),t("p",[v._v("HTTP1.0使用头部的Expires和Pragma来控制缓存")]),v._v(" "),t("p",[v._v("HTTP1.1支持了更多的缓存策略，Etag、If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match、Cache-Control")])])])]),v._v(" "),t("li",[t("p",[v._v("HTTP1.1与HTTP 2.0的区别")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("多路复用")]),v._v(" "),t("p",[v._v("在HTTP1.1协议中，浏览器客户端在同一时间针对同一域名的请求有一定数据限制，超过限制数目的请求会被阻塞")]),v._v(" "),t("p",[v._v("HTTP 2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP 1.1大了好几个数量级")])]),v._v(" "),t("li",[t("p",[v._v("二进制分帧")]),v._v(" "),t("p",[v._v("在应用层和传输层之间增加一个二进制分帧层")])]),v._v(" "),t("li",[t("p",[v._v("首部压缩")]),v._v(" "),t("p",[v._v("HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快")])]),v._v(" "),t("li",[t("p",[v._v("服务器推送")]),v._v(" "),t("p",[v._v("服务端推送是一种在客户端请求之前发送数据的机制")]),v._v(" "),t("p",[v._v("当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源")]),v._v(" "),t("p",[v._v("服务器推送可以缓存，并且在遵循同源的情况下，不同页面之间可以共享缓存")])])])]),v._v(" "),t("li",[t("p",[v._v("HTTP和HTTPS有什么不同")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("HTTP")]),v._v(" "),t("p",[v._v("超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少")])]),v._v(" "),t("li",[t("p",[v._v("HTTPS")]),v._v(" "),t("p",[v._v("以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密，下层的协议由 TCP/IP 换成了 SSL/TLS")])])])]),v._v(" "),t("li",[t("p",[v._v("HTTP状态码")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("分类")]),v._v(" "),t("th",[v._v("分类描述")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("1**")]),v._v(" "),t("td",[v._v("信息，服务器收到请求，需要请求者继续执行操作")])]),v._v(" "),t("tr",[t("td",[v._v("2**")]),v._v(" "),t("td",[v._v("成功，操作被成功接收并处理")])]),v._v(" "),t("tr",[t("td",[v._v("3**")]),v._v(" "),t("td",[v._v("重定向，需要进一步的操作以完成请求")])]),v._v(" "),t("tr",[t("td",[v._v("4**")]),v._v(" "),t("td",[v._v("客户端错误，请求包含语法错误或无法完成请求")])]),v._v(" "),t("tr",[t("td",[v._v("5**")]),v._v(" "),t("td",[v._v("服务器错误，服务器在处理请求的过程中发生了错误")])])])])]),v._v(" "),t("li",[t("p",[v._v("HTTP请求方法")]),v._v(" "),t("ul",[t("li",[v._v("GET：通常用来获取资源")]),v._v(" "),t("li",[v._v("HEAD：获取资源的元信息")]),v._v(" "),t("li",[v._v("POST：提交数据，即上传数据")]),v._v(" "),t("li",[v._v("PUT：修改数据")]),v._v(" "),t("li",[v._v("DELETE：删除资源(几乎用不到)")]),v._v(" "),t("li",[v._v("CONNECT：建立连接隧道，用于代理服务器")]),v._v(" "),t("li",[v._v("OPTIONS：列出可对资源实行的请求方法，用来跨域请求(复杂请求先发此请求，用于确定目标资源是否支持跨域)")]),v._v(" "),t("li",[v._v("TRACE：追踪请求-响应的传输路径")])])]),v._v(" "),t("li",[t("p",[v._v("HTTP中的头")]),v._v(" "),t("ul",[t("li",[v._v("请求头\n"),t("ul",[t("li",[v._v("accept-encoding：告诉服务器，接收的数据支持压缩格式(gzip是当今最流行的压缩格式)")]),v._v(" "),t("li",[v._v("if-modified-since：协商缓存修改时间")]),v._v(" "),t("li",[v._v("if-none-match：协商缓存和Etag配对使用")]),v._v(" "),t("li",[v._v("user-agent：不同设备自动带上这个头，判断什么设备，重定向到不同项目")])])]),v._v(" "),t("li",[v._v("响应头\n"),t("ul",[t("li",[v._v("Content-Type：告诉浏览器，传过来内容的类型")]),v._v(" "),t("li",[v._v("Content-Encoding：告诉浏览器，传过来内容的压缩格式")]),v._v(" "),t("li",[v._v("Cache-Control：强制缓存 http1.1")]),v._v(" "),t("li",[v._v("Expires：强制缓存 http1.0")]),v._v(" "),t("li",[v._v("Last-Modified：协商缓存和if-modified-since配对使用")]),v._v(" "),t("li",[v._v("Etag：协商缓存和if-none-match配对使用")])])])])]),v._v(" "),t("li",[t("p",[v._v("HTTP处理大文件传输")]),v._v(" "),t("p",[v._v("采取范围请求的解决方案，允许客户端仅仅请求一个资源的一部分")]),v._v(" "),t("p",[v._v("服务端设置响应头Accept-Ranges: none")]),v._v(" "),t("p",[v._v("客户端设置请求头：")]),v._v(" "),t("div",{staticClass:"language-text extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("// 单段数据\nRange: bytes=0-9\n// 多段数据\nRange: bytes=0-9, 30-39\n")])])])]),v._v(" "),t("li",[t("p",[v._v("HTTP队头阻塞问题解决方法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("并发连接")]),v._v(" "),t("p",[v._v("同时对一个域名发起多个长连接，用数量来解决质量的问题")])]),v._v(" "),t("li",[t("p",[v._v("域名分片")]),v._v(" "),t("p",[v._v("多开域名，全部指向同一台服务器")])])])])]),v._v(" "),t("h2",{attrs:{id:"https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),t("blockquote",[t("p",[v._v("HTTPS并不是新的协议，而是加强版的HTTP，原理是在http和tcp之间建立了一个中间层，http和tcp并不能像之前那样直接通信，需要通过中间层进行加密，将加密后的数据包传给tcp，相应的，tcp必须将数据包解密之后才能传给http")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("对称加密和非对称加密")]),v._v(" "),t("p",[v._v("对称加密是最简单的方式，指的是加密和解密用的同样的密钥")]),v._v(" "),t("p",[v._v("非对称加密，如果有A、B两把密钥，用A加密过的数据包只能用B解密，反之，B加密过的数据包只能用A解密")])])])])}),[],!1,null,null,null);_.default=p.exports}}]);