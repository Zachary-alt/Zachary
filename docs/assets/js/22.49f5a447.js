(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{396:function(v,_,t){"use strict";t.r(_);var s=t(42),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"算法技巧总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法技巧总结"}},[v._v("#")]),v._v(" 算法技巧总结")]),v._v(" "),t("h2",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[v._v("#")]),v._v(" 动态规划")]),v._v(" "),t("p",[v._v("动态规划，无非就是利用"),t("strong",[v._v("历史记录")]),v._v("，来避免我们的重复计算。而这些"),t("strong",[v._v("历史记录")]),v._v("，我们得需要一些"),t("strong",[v._v("变量")]),v._v("来保存，一般是用"),t("strong",[v._v("一维数组")]),v._v("或者"),t("strong",[v._v("二维数组")]),v._v("来保存。")]),v._v(" "),t("h3",{attrs:{id:"第一步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一步骤"}},[v._v("#")]),v._v(" "),t("strong",[v._v("第一步骤")])]),v._v(" "),t("p",[v._v("定义"),t("strong",[v._v("数组元素的含义")]),v._v("，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？")]),v._v(" "),t("h3",{attrs:{id:"第二步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二步骤"}},[v._v("#")]),v._v(" "),t("strong",[v._v("第二步骤")])]),v._v(" "),t("p",[v._v("找出"),t("strong",[v._v("数组元素之间的关系式")]),v._v("，我觉得动态规划，还是有一点类似于我们高中学习时的"),t("strong",[v._v("归纳法")]),v._v("的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的，也就是可以利用"),t("strong",[v._v("历史数据")]),v._v("来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步。")]),v._v(" "),t("h3",{attrs:{id:"第三步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三步骤"}},[v._v("#")]),v._v(" "),t("strong",[v._v("第三步骤")])]),v._v(" "),t("p",[v._v("找出"),t("strong",[v._v("初始值")]),v._v("。学过"),t("strong",[v._v("数学归纳法")]),v._v("的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是"),t("strong",[v._v("所谓的初始值")]),v._v("。")]),v._v(" "),t("p",[v._v("由了"),t("strong",[v._v("初始值")]),v._v("，并且有了"),t("strong",[v._v("数组元素之间的关系式")]),v._v("，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想"),t("strong",[v._v("求什么，就定义它是什么")]),v._v("，这样，这道题也就解出来了。")]),v._v(" "),t("h2",{attrs:{id:"回溯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[v._v("#")]),v._v(" 回溯")]),v._v(" "),t("p",[v._v("回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。")]),v._v(" "),t("p",[v._v("用回溯算法解决问题的一般步骤：")]),v._v(" "),t("blockquote",[t("ol",[t("li",[v._v("针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。")]),v._v(" "),t("li",[v._v("确定易于搜索的解空间结构,使得能用"),t("code",[v._v("回溯法")]),v._v("方便地搜索整个解空间 。")]),v._v(" "),t("li",[v._v("以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。")])])]),v._v(" "),t("p",[v._v("回溯法可以理解成为通过选择不同的岔路口，来寻找目的地，一个岔路口一个岔路口的去尝试找到目的地，如果走错了路的话，继续返回到上一个岔路口的另外一条路，直到找到目的地。")]),v._v(" "),t("h3",{attrs:{id:"基本套路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本套路"}},[v._v("#")]),v._v(" 基本套路")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("「路径」")]),v._v("：记录做出的选择。")]),v._v(" "),t("li",[t("strong",[v._v("「选择列表」")]),v._v("：通常而言，用数组存储可以选择的操作。")]),v._v(" "),t("li",[t("strong",[v._v("「结束条件」")]),v._v("：一般而言，就是递归的结束点，也就是搜索的结束点。")]),v._v(" "),t("li",[t("strong",[v._v("「回溯优化」")]),v._v(" :配合剪枝函数进行优化，通过这个函数，我们可以减去一些不可能到达到终点的条件，")])])])}),[],!1,null,null,null);_.default=r.exports}}]);